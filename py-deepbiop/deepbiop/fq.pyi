# This file is automatically generated by pyo3_stub_gen

import builtins
import os
import pathlib
import typing

@typing.final
class EncoderOption:
    @property
    def qual_offset(self) -> builtins.int: ...
    @qual_offset.setter
    def qual_offset(self, value: builtins.int) -> None: ...
    @property
    def bases(self) -> builtins.list[builtins.int]: ...
    @bases.setter
    def bases(self, value: builtins.list[builtins.int]) -> None: ...
    @property
    def threads(self) -> builtins.int: ...
    @threads.setter
    def threads(self, value: builtins.int) -> None: ...
    def __new__(
        cls,
        qual_offset: builtins.int,
        bases: builtins.str,
        threads: builtins.int | None = None,
    ) -> EncoderOption: ...

@typing.final
class FastqDataset:
    def __new__(
        cls, file_path: builtins.str, chunk_size: builtins.int
    ) -> FastqDataset: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, idx: builtins.int) -> typing.Any: ...
    def __iter__(self) -> FastqIterator: ...
    @staticmethod
    def from_file(
        file_path: builtins.str, chunk_size: builtins.int
    ) -> FastqDataset: ...
    def get_stats(self) -> typing.Any: ...
    def get_records(
        self, start: builtins.int, end: builtins.int
    ) -> builtins.list[FastqRecord]: ...
    def get_records_indexed(
        self, start: builtins.int, end: builtins.int
    ) -> builtins.list[FastqRecord]: ...
    def get_records_sequential(
        self, start: builtins.int, end: builtins.int
    ) -> builtins.list[FastqRecord]: ...

@typing.final
class FastqIterator:
    def __iter__(self) -> FastqIterator: ...
    def __next__(self) -> typing.Any | None: ...

@typing.final
class FastqRecord:
    @property
    def header(self) -> builtins.str: ...
    @property
    def sequence(self) -> builtins.str: ...
    @property
    def quality(self) -> builtins.str: ...
    def __new__(
        cls, header: builtins.str, sequence: builtins.str, quality: builtins.str
    ) -> FastqRecord: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class ParquetEncoder:
    def __new__(cls, option: EncoderOption) -> ParquetEncoder: ...

@typing.final
class Predict:
    r"""A struct to store the prediction result."""

    @property
    def prediction(self) -> builtins.list[builtins.int]: ...
    @prediction.setter
    def prediction(self, value: builtins.list[builtins.int]) -> None: ...
    @property
    def seq(self) -> builtins.str: ...
    @seq.setter
    def seq(self, value: builtins.str) -> None: ...
    @property
    def id(self) -> builtins.str: ...
    @id.setter
    def id(self, value: builtins.str) -> None: ...
    @property
    def is_truncated(self) -> builtins.bool: ...
    @is_truncated.setter
    def is_truncated(self, value: builtins.bool) -> None: ...
    @property
    def qual(self) -> builtins.str | None: ...
    @qual.setter
    def qual(self, value: builtins.str | None) -> None: ...
    def __new__(
        cls,
        prediction: typing.Sequence[builtins.int],
        seq: builtins.str,
        id: builtins.str,
        is_truncated: builtins.bool,
        qual: builtins.str | None = None,
    ) -> Predict: ...
    def __repr__(self) -> builtins.str: ...
    def prediction_region(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""Get the prediction region."""
    def smooth_prediction(
        self, window_size: builtins.int
    ) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""Get the smooth prediction region."""
    def smooth_label(self, window_size: builtins.int) -> builtins.list[builtins.int]:
        r"""Get the smooth label."""
    def smooth_and_select_intervals(
        self,
        smooth_window_size: builtins.int,
        min_interval_size: builtins.int,
        append_interval_number: builtins.int,
    ) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""Smooth and select intervals."""
    def seq_len(self) -> builtins.int:
        r"""Get the sequence length."""
    def qual_array(self) -> builtins.list[builtins.int]:
        r"""Get the quality score array."""
    def show_info(
        self,
        smooth_interval: typing.Sequence[tuple[builtins.int, builtins.int]],
        text_width: builtins.int | None = None,
    ) -> builtins.str:
        r"""Show the information of the prediction."""
    def __getstate__(self) -> typing.Any: ...
    def __setstate__(self, state: typing.Any) -> None: ...

@typing.final
class RecordData:
    @property
    def id(self) -> builtins.str: ...
    @id.setter
    def id(self, value: builtins.str) -> None: ...
    @property
    def seq(self) -> builtins.str: ...
    @seq.setter
    def seq(self, value: builtins.str) -> None: ...
    @property
    def qual(self) -> builtins.str: ...
    @qual.setter
    def qual(self, value: builtins.str) -> None: ...
    def __new__(
        cls, id: builtins.str, seq: builtins.str, qual: builtins.str
    ) -> RecordData: ...

def convert_multiple_fqs_to_one_fq(
    paths: typing.Sequence[builtins.str | os.PathLike | pathlib.Path],
    result_path: builtins.str | os.PathLike | pathlib.Path,
    parallel: builtins.bool,
) -> None: ...
def encode_fq_path_to_parquet(
    fq_path: builtins.str | os.PathLike | pathlib.Path,
    bases: builtins.str,
    qual_offset: builtins.int,
    result_path: builtins.str | os.PathLike | pathlib.Path | None = None,
) -> None: ...
def encode_fq_path_to_parquet_chunk(
    fq_path: builtins.str | os.PathLike | pathlib.Path,
    chunk_size: builtins.int,
    parallel: builtins.bool,
    bases: builtins.str,
    qual_offset: builtins.int,
) -> None: ...
def encode_fq_paths_to_parquet(
    fq_path: typing.Sequence[builtins.str | os.PathLike | pathlib.Path],
    bases: builtins.str,
    qual_offset: builtins.int,
) -> None: ...
def encode_qual(
    qual: builtins.str, qual_offset: builtins.int
) -> builtins.list[builtins.int]:
    r"""Convert ASCII quality to Phred score for Phred+33 encoding."""

def fastq_to_fasta(
    fastq_path: builtins.str | os.PathLike | pathlib.Path,
    fasta_path: builtins.str | os.PathLike | pathlib.Path,
) -> None: ...
def get_label_region(
    labels: typing.Sequence[builtins.int],
) -> builtins.list[tuple[builtins.int, builtins.int]]: ...
def load_predicts_from_batch_pt(
    pt_path: builtins.str | os.PathLike | pathlib.Path,
    ignore_label: builtins.int,
    id_table: typing.Mapping[builtins.int, builtins.str],
) -> builtins.dict[builtins.str, Predict]: ...
def load_predicts_from_batch_pts(
    pt_path: builtins.str | os.PathLike | pathlib.Path,
    ignore_label: builtins.int,
    id_table: typing.Mapping[builtins.int, builtins.str],
    max_predicts: builtins.int | None = None,
) -> builtins.dict[builtins.str, Predict]: ...
def select_record_from_fq(
    selected_reads: typing.Sequence[builtins.str],
    fq: builtins.str | os.PathLike | pathlib.Path,
    output: builtins.str | os.PathLike | pathlib.Path,
) -> None: ...
def select_record_from_fq_by_random(
    fq: builtins.str | os.PathLike | pathlib.Path,
    number: builtins.int,
    output: builtins.str | os.PathLike | pathlib.Path,
) -> None: ...
def test_predicts(predicts: typing.Sequence[Predict]) -> None: ...
def write_fq(
    records_data: typing.Sequence[RecordData],
    file_path: builtins.str | os.PathLike | pathlib.Path | None = None,
) -> None: ...
def write_fq_parallel(
    records_data: typing.Sequence[RecordData],
    file_path: builtins.str | os.PathLike | pathlib.Path,
    threads: builtins.int,
) -> None: ...
